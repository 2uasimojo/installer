package gencrypto

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/x509"
	"encoding/pem"

	"github.com/openshift/installer/pkg/asset"
)

// AuthConfig is an asset that generates ECDSA public and private keys.
type AuthConfig struct {
	PublicKey, PrivateKey string
}

var _ asset.WritableAsset = (*AuthConfig)(nil)

// Dependencies returns the assets on which the AuthConfig asset depends.
func (a *AuthConfig) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate generates the auth config for agent installer APIs.
func (a *AuthConfig) Generate(dependencies asset.Parents) error {
	PublicKey, PrivateKey, err := keyPairPEM()
	if err != nil {
		return err
	}
	a.PublicKey = PublicKey
	a.PrivateKey = PrivateKey

	return nil
}

// Name returns the human-friendly name of the asset.
func (a *AuthConfig) Name() string {
	return "Agent Installer API Auth Config"
}

// Load returns the auth config from disk.
func (a *AuthConfig) Load(f asset.FileFetcher) (bool, error) {
	// The AuthConfig will not be needed by another asset so load is noop.
	// This is implemented because it is required by WritableAsset
	return false, nil
}

// Files returns the files generated by the asset.
func (a *AuthConfig) Files() []*asset.File {
	// Return empty array because File will never be loaded.
	return []*asset.File{}
}

// Reused from assisted-service.
// https://github.com/openshift/assisted-service/blob/d3c0122452c74ad208055b8b6ee412812431a83f/internal/gencrypto/keys.go#L13-L54
func keyPairPEM() (string, string, error) {
	priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return "", "", err
	}

	// encode private key to PEM string
	privBytes, err := x509.MarshalECPrivateKey(priv)
	if err != nil {
		return "", "", err
	}

	block := &pem.Block{
		Type:  "EC PRIVATE KEY",
		Bytes: privBytes,
	}

	var privKeyPEM bytes.Buffer
	err = pem.Encode(&privKeyPEM, block)
	if err != nil {
		return "", "", err
	}

	// encode public key to PEM string
	pubBytes, err := x509.MarshalPKIXPublicKey(priv.Public())
	if err != nil {
		return "", "", err
	}

	block = &pem.Block{
		Type:  "EC PUBLIC KEY",
		Bytes: pubBytes,
	}

	var pubKeyPEM bytes.Buffer
	err = pem.Encode(&pubKeyPEM, block)
	if err != nil {
		return "", "", err
	}

	return pubKeyPEM.String(), privKeyPEM.String(), nil
}
