package agentconfig

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"sigs.k8s.io/yaml"

	aiv1beta1 "github.com/openshift/assisted-service/api/v1beta1"
	"github.com/openshift/installer/pkg/asset"
	agentAsset "github.com/openshift/installer/pkg/asset/agent"
	"github.com/openshift/installer/pkg/types/agent"
	"github.com/openshift/installer/pkg/types/baremetal"
	"github.com/openshift/installer/pkg/types/baremetal/validation"
	"github.com/openshift/installer/pkg/validate"
)

var (
	_ asset.WritableAsset = (*AgentHosts)(nil)
)

// AgentHosts generates the hosts information from the AgentConfig and
// OptionalInstallConfig assets.
type AgentHosts struct {
	Hosts        []agent.Host
	RendezvousIP string
}

// Name returns a human friendly name.
func (a *AgentHosts) Name() string {
	return "Agent Hosts"
}

// Dependencies returns all of the dependencies directly needed the asset.
func (a *AgentHosts) Dependencies() []asset.Asset {
	return []asset.Asset{
		&agentAsset.OptionalInstallConfig{},
		&AgentConfig{},
	}
}

// Generate generates the Hosts data.
func (a *AgentHosts) Generate(dependencies asset.Parents) error {
	agentConfig := &AgentConfig{}
	installConfig := &agentAsset.OptionalInstallConfig{}
	dependencies.Get(agentConfig, installConfig)
	var hostsFromInstallConfig = false

	if agentConfig.Config != nil {
		a.RendezvousIP = agentConfig.Config.RendezvousIP
		for _, host := range agentConfig.Config.Hosts {
			a.Hosts = append(a.Hosts, host)
		}
	}

	if installConfig != nil && installConfig.Config != nil {
		if installConfig.Config.Platform.Name() == baremetal.Name && len(installConfig.Config.Platform.BareMetal.Hosts) > 0 {
			fieldPath := field.NewPath("Platform", "Baremetal", "Hosts")
			if len(a.Hosts) == 0 {
				logrus.Debugf("Using %s from %s", fieldPath, agentAsset.InstallConfigFilename)
				hostsFromInstallConfig = true
				if err := a.getInstallConfigDefaults(installConfig.Config.Platform.BareMetal); err != nil {
					return errors.Wrapf(err, "invalid host definition in %s", agentAsset.InstallConfigFilename)
				}
			} else {
				logrus.Warnf(fmt.Sprintf("%s from %s is ignored", fieldPath, agentAsset.InstallConfigFilename))
			}
		}
	}

	if err := a.validateAgentHosts().ToAggregate(); err != nil {
		if hostsFromInstallConfig {
			return errors.Wrapf(err, "invalid Install Config configuration")
		} else {
			return errors.Wrapf(err, "invalid Agent Config configuration")
		}
	}

	return nil
}

// Files returns the files generated by the asset.
func (m *AgentHosts) Files() []*asset.File {
	return nil
}

// Load currently does nothing.
func (a *AgentHosts) Load(f asset.FileFetcher) (bool, error) {
	return false, nil
}

func (a *AgentHosts) validateAgentHosts() field.ErrorList {
	allErrs := field.ErrorList{}

	macs := make(map[string]bool)
	for i, host := range a.Hosts {
		hostPath := field.NewPath("Hosts").Index(i)

		if err := a.validateHostInterfaces(hostPath, host, macs); err != nil {
			allErrs = append(allErrs, err...)
		}

		if err := a.validateHostRootDeviceHints(hostPath, host); err != nil {
			allErrs = append(allErrs, err...)
		}

		if err := a.validateRoles(hostPath, host); err != nil {
			allErrs = append(allErrs, err...)
		}
	}

	if err := a.validateRendezvousIPNotWorker(a.RendezvousIP, a.Hosts); err != nil {
		allErrs = append(allErrs, err...)
	}

	return allErrs
}

func (a *AgentHosts) validateHostInterfaces(hostPath *field.Path, host agent.Host, macs map[string]bool) field.ErrorList {
	var allErrs field.ErrorList

	interfacePath := hostPath.Child("Interfaces")
	if len(host.Interfaces) == 0 {
		allErrs = append(allErrs, field.Required(interfacePath, "at least one interface must be defined for each node"))
	}

	for j := range host.Interfaces {
		mac := host.Interfaces[j].MacAddress
		macAddressPath := interfacePath.Index(j).Child("macAddress")

		if mac == "" {
			allErrs = append(allErrs, field.Required(macAddressPath, "each interface must have a MAC address defined"))
			continue
		}

		if err := validate.MAC(mac); err != nil {
			allErrs = append(allErrs, field.Invalid(macAddressPath, mac, err.Error()))
		}

		if _, ok := macs[mac]; ok {
			allErrs = append(allErrs, field.Invalid(macAddressPath, mac, "duplicate MAC address found"))
		}
		macs[mac] = true
	}

	return allErrs
}

func (a *AgentHosts) validateHostRootDeviceHints(hostPath *field.Path, host agent.Host) field.ErrorList {
	rdhPath := hostPath.Child("rootDeviceHints")
	allErrs := validation.ValidateHostRootDeviceHints(&host.RootDeviceHints, rdhPath)

	if host.RootDeviceHints.WWNWithExtension != "" {
		allErrs = append(allErrs, field.Forbidden(
			rdhPath.Child("wwnWithExtension"), "WWN extensions are not supported in root device hints"))
	}

	if host.RootDeviceHints.WWNVendorExtension != "" {
		allErrs = append(allErrs, field.Forbidden(rdhPath.Child("wwnVendorExtension"), "WWN vendor extensions are not supported in root device hints"))
	}

	return allErrs
}

func (a *AgentHosts) validateRoles(hostPath *field.Path, host agent.Host) field.ErrorList {
	var allErrs field.ErrorList

	if len(host.Role) > 0 && host.Role != "master" && host.Role != "worker" {
		allErrs = append(allErrs, field.Forbidden(hostPath.Child("Host"), "host role has incorrect value. Role must either be 'master' or 'worker'"))
	}

	return allErrs
}

func (a *AgentHosts) validateRendezvousIPNotWorker(rendezvousIP string, hosts []agent.Host) field.ErrorList {
	var allErrs field.ErrorList

	if rendezvousIP != "" {
		for i, host := range hosts {
			hostPath := field.NewPath("Hosts").Index(i)
			if strings.Contains(string(host.NetworkConfig.Raw), rendezvousIP) && host.Role == "worker" {
				errMsg := "Host " + host.Hostname + " has role 'worker' and has the rendezvousIP assigned to it. The rendezvousIP must be assigned to a control plane host."
				allErrs = append(allErrs, field.Forbidden(hostPath.Child("Host"), errMsg))
			}
		}
	}
	return allErrs
}

// Add the baremetal hosts defined in install-config to the agent-config.
func (a *AgentHosts) getInstallConfigDefaults(platform *baremetal.Platform) error {
	for _, icHost := range platform.Hosts {
		if icHost.BootMACAddress == "" {
			return errors.New("host bootMACAddress is required")
		}

		host := agent.Host{
			Hostname: icHost.Name,
			Role:     icHost.Role,
		}
		if icHost.RootDeviceHints != nil {
			host.RootDeviceHints = *icHost.RootDeviceHints
		}
		if icHost.NetworkConfig != nil {
			contents, err := yaml.JSONToYAML(icHost.NetworkConfig.Raw)
			if err != nil {
				return errors.Wrap(err, "failed to unmarshal networkConfig")
			}
			host.NetworkConfig.Raw = contents
		}

		// Create Interfaces field from BootMacAddress
		hostInterface := &aiv1beta1.Interface{
			Name:       "boot",
			MacAddress: icHost.BootMACAddress,
		}
		host.Interfaces = append(host.Interfaces, hostInterface)

		a.Hosts = append(a.Hosts, host)
	}

	return nil
}

// HostConfigFileMap is a map from a filepath ("<host>/<file>") to file content
// for hostconfig files.
type HostConfigFileMap map[string][]byte

// HostConfigFiles returns a map from filename to contents of the files used for
// host-specific configuration by the agent installer client.
func (a *AgentHosts) HostConfigFiles() (HostConfigFileMap, error) {
	if a == nil {
		return nil, nil
	}

	files := HostConfigFileMap{}
	for i, host := range a.Hosts {
		name := fmt.Sprintf("host-%d", i)
		if host.Hostname != "" {
			name = host.Hostname
		}

		macs := []string{}
		for _, iface := range host.Interfaces {
			macs = append(macs, strings.ToLower(iface.MacAddress)+"\n")
		}

		if len(macs) > 0 {
			files[filepath.Join(name, "mac_addresses")] = []byte(strings.Join(macs, ""))
		}

		rdh, err := yaml.Marshal(host.RootDeviceHints)
		if err != nil {
			return nil, err
		}
		if len(rdh) > 0 && string(rdh) != "{}\n" {
			files[filepath.Join(name, "root-device-hints.yaml")] = rdh
		}

		if len(host.Role) > 0 {
			files[filepath.Join(name, "role")] = []byte(host.Role)
		}
	}
	return files, nil
}
